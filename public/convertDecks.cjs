const fs = require("fs");
const path = require("path");
const { pinyin } = require("pinyin-pro");
const nodejieba = require("nodejieba");
const lookup = require("./cedict/dictionary.cjs");

const dataPath = path.join(__dirname, "../decks/data");
const outputFile = path.join(__dirname, "../decks/generatedDecks.ts");

function getAllCsvFiles(dir) {
  let results = [];
  const list = fs.readdirSync(dir);

  list.forEach((file) => {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);
    if (stat && stat.isDirectory()) {
      results = results.concat(getAllCsvFiles(fullPath));
    } else if (file.endsWith(".csv")) {
      results.push(fullPath);
    }
  });

  return results;
}

function parseDeckFile(filePath) {
  const terms = new Set();

  const content = fs.readFileSync(filePath, "utf-8");
  const lines = content.split(/\r?\n/).filter(Boolean);

  // First line: deck name and desc separated by tab(s) or multiple spaces
  const [deckName, desc, param] = lines[0].split(",");
  const mode = param ? param : "pinyin";

  // Subsequent lines: cards with term and definition
  const cards = lines.slice(1).map((line) => {
    const [term, ...defParts] = line.split(",");

    const words = nodejieba.cut(term);
    const pinyinStr = words
      .map((word) =>
        pinyin(word, { toneType: "symbol", type: "array" }).join("")
      )
      .join(" ")
      .replaceAll(" 。 ", ". ")
      .replaceAll(" ， ", ", ");
    const tonelessStr = words
      .map((word) => pinyin(word, { toneType: "none", type: "array" }).join(""))
      .join(" ")
      .replaceAll(" 。 ", ". ")
      .replaceAll(" ， ", ", ");

    terms.add(term);

    return {
      term: term.trim(),
      pinyin: pinyinStr.trim(),
      toneless: tonelessStr.trim(),
      definition: defParts
        .join(",")
        .replace(/^["']|["']$/g, "")
        .trim(),
      mode: mode,
    };
  });

  const characters = new Set();
  [...terms].map((term) => {
    term.split("").map((character) => {
      characters.add(character);
    });
  });

  [...characters].map((character) => {
    if (lookup(character)) {
      cards.push({
        term: character,
        readings: lookup(character),
        mode: "hanzi",
      });
    }
  });

  return { deckName, desc, cards };
}

function main() {
  const csvFiles = getAllCsvFiles(dataPath);

  const decks = {};

  csvFiles.forEach((filePath) => {
    const folder = path.basename(path.dirname(filePath));
    const fileName = path.basename(filePath, ".csv"); // filename without extension
    const { deckName, desc, cards } = parseDeckFile(filePath);

    decks[fileName] = {
      name: deckName,
      folder,
      desc,
      cards,
    };
  });

  const fileContent = `
// This file is auto-generated by scripts/generateDecks.js
import type { Decks } from "./utilities";

export const decks: Decks = ${JSON.stringify(decks, null, 2)};
`;

  fs.writeFileSync(outputFile, fileContent, "utf-8");
  console.log(
    "generatedDecks.ts created with",
    Object.keys(decks).length,
    "decks."
  );
}

main();
